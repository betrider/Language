**모든함수
함수정보1):http://najuung.tistory.com/55**
	  		2):http://mirwebma.tistory.com/14
	  		3)http://zyni23.blog.me/20190872935
	  		
함수목록:http://stargrape.tistory.com/entry/%EC%98%A4%EB%9D%BC%ED%81%B4-%ED%95%A8%EC%88%98-%EB%AA%A9%EB%A1%9D

MD5 복호화 아닌 DB 사이트
https://www.hashkiller.co.uk/md5-decrypter.aspx

*오라클 계정비밀번호 만료

ALTER USER 유저명 IDENTIFIED BY 비밀번호 

*Funtion() -http://hunit.tistory.com/219 // 형변환 함수-http://lkrox.blogspot.kr/2013/01/blog-post_31.html
1)UFN_DATE_FORMAT()-> UFN_DATE_FORMAT('DATE')-EX)20170103 , UFN_DATE_FORMAT('TIME')-EX)103843(시,분,초)
2)UFN_TABLE_ITEM()
3)UFN_GET_NAME_ADDR()
4)UFN_IATA_TARIFF()
5)UFN_LOCAL_NAME()
6)UNF_MD5_ENCRYPTION()

=================== **select 문의 처리순서
select 컬럼명 --(5)
from 테이블명 --(1)
where 조건절  --(2)
//(1),(2)를 한 것은 해당 테이블에서 조건에 만족하는 행을 메모리(RAM)에 로드시킨것
group by절 --(3)
having 그룹함수 조건절 --(4)
order by절 --(6)
===================

**디비링크(DBLINK)
TNS정보는 데이터베이스 서버 TNS정보타고들어감

**날짜형식 다르게 나오면 F5 <-> SHIFT F9

DATE 형식 컬럼 가지고올때

TO_CHAR(INVOICE_DATE,'YYYY-MM-DD AM HH:MI:SS') AS INVOICE_DATE

,TO_CHAR(TO_DATE('201810251334','YYYYMMDDHH24MI'),'YYYY-MM-DD AM HH:MI')  AS TS_ETD

EX)2018-10-04 오후 04:58:56

저장할때 

TO_DATE('2014-04-04 오후 02:57:11','YYYY-MM-DD AM HH:MI:SS')

**소수점 포맷
TO_CHAR(CHB_WGT,'FM999990.000')

**
SELECT * 
  FROM ALL_TAB_COLUMNS
  
SELECT *
  FROM ALL_INDEXES

===================
*명령어
1.AS - 다른이름으로 선언
EX)SELECT A.AMD_NO AS NUM

2.group by and having- 데이터 집계를 나타낼때(WHERE 사용하면 안됨)
ex)
SELECT [GROUP BY 절에 지정된 컬럼1] [GROUP BY별로 집계할 값] 
FROM [테이블 명] 
GROUP BY [ 그룹으로 묶을 컬럼 값 ]
HAVING [조건 추가] ;

EX) SELECT A, SUM(B)
		FROM(
		SELECT '1' AS A , '7' AS B FROM DUAL
		UNION 
		SELECT '1' AS A , '8' AS B FROM DUAL)
		GROUP BY A

3.BEGIN - END 쿼리 시작과끝 묶어주는 역할
EX)BEGIN
   {
   {
   {
   END;

4.NVL('A','B')-NVL('입력되는자료값(A)','입력되는 자료값이 일 경우 나타낼 값(B)')
  EX)NVL('0','ASDF')

5.NVL2('data','A','B')-NVL2('입력되는자료값(data)','입력되는자료값이 NULL이 아닐때(A 출력)','입력되는자료값이 NULL일때(B 출력))

6.MAX,MIN,AVG,SUM,COUNT - MAX(컬럼명),MIN(컬럼명),AVG(컬럼명),SUM(컬럼명),COUNT(*) 최대값,최소값,평균값,총합,갯수 나타냄
EX)
SELECT MAX(A.MBL_NO) --1
         ,  MIN(A.MBL_NO) --2
         ,  AVG(A.CUSTOMS_CD)--3
         ,  SUM(A.CUSTOMS_CD)--4
         ,  COUNT(*) --5
FROM  FMS_AMD_MST A
WHERE A.TRMS_REQ_YMD = '20160125'

7.UNION,UNION ALL,INTERSECT,MINUS - 중복된 값 제거 (2,3)(3,4)->(2,3,4) , 모든값 (2,3)(3,4)->(2,3,3,4) , 교집합-공통된값만 출력 (2,3)(3,4)->(3), 차집합-중복제거하고 A결과만 보여주기 (2,3)(3,4)->(2)
ex)
SELECT A.AMD_NO
FROM FMS_AMD_MST A
(명령어)
SELECT B.AMD_NO 
FROM FMS_AMD_LOG B     //A+B => A
												   	    B

8.MERGE(UPDATE&INSERT&DELETE를 한번에 해결하는 구문)+USING
EX) MERGE INTO  WMS_ETC_DTL A
    USING ( SELECT  'TS1' AS WH_CD, 'AS201607110011' AS ORD_NO, '1' AS ORD_SEQ,'동태LLL' SKU_NM  FROM DUAL) B - 가상테이블 생성
    ON (A.WH_CD=B.WH_CD AND A.ORD_NO=B.ORD_NO AND A.ORD_SEQ=B.ORD_SEQ) - 조건부분
    WHEN MATCHED THEN -조건 TRUE일 경우
              UPDATE SET   SKU_NM=B.SKU_NM
     WHEN NOT MATCHED THEN -조건 FALSE일 경우
            INSERT  ( WH_CD
                    , ORD_NO
                    , ORD_SEQ
                    , SKU_NM
            ) VALUES
                    (B.WH_CD,B.ORD_NO,B.ORD_SEQ,B.SKU_NM
            );
-----------------------------------------------------------
MERGE INTO 테이블명
		USING (가상 테이블 생성)
		ON(조건)
				WHEN MATCHED THEN
				--(UPDATE 부분)
				WHEN NOT MATCHED THEN
				--(INSERT 부분)
				
9.JOIN(INNER JOIN, OUTER JOIN, LEFT JOIN, RIGHT JOIN) - 참조사이트:https://ko.wikipedia.org/wiki/Join_(SQL)

1)INNER JOIN(기본 조인 형식) 두 테이블이 일치하는 열만 가지고 온다. (*ON 은 JOIN문 쓸때 사용하는 조건문(WHERE과 다르게 테이블 생성전에 조건검사를 한다.)

EX)명시적 표현(MSSQL 방식)
	 SELECT *
	 FROM employee INNER JOIN department
   ON employee.DepartmentID = department.DepartmentID;

EX)암시적 표현(ORACLE 방식)
SELECT *
FROM employee, department
WHERE employee.DepartmentID = department.DepartmentID;

2)LEFT OUTER JOIN - 왼쪽 외부조인(왼쪽 기준)
왼쪽에 컬럼값은 다 나오고 오른쪽에 해당안되는 컬럼은 NULL값으로 나온다.
EX)암시적 표현(ORACLE 방식)
SELECT *
FROM employee, department
WHERE employee.DepartmentID(+) = department.DepartmentID;

3)RIGHT OUTER JOIN - 오른쪽 외부조인(오른쪽 기준)
오른쪽에 컬럼값은 다 나오고 오른쪽에 해당안되는 컬럼은 NULL값으로 나온다.
EX)암시적 표현(ORACLE 방식)
SELECT *
FROM employee, department
WHERE employee.DepartmentID = department.DepartmentID(+);    A JOIN B = AB

10.DECODE - 참 거짓 값에 따라 출력해줌
DECODE(테이블,컬럼, 비교 대상 ,맞을때, 틀릴때)
ex)DECODE('왼쪽값','오른쪽값','TRUE일때','FALSE일때') 왼쪽값과 오른쪽 값이 같을때는 TRUE 출력 아닐때는 FALSE 출력 

11.T0_CHAR()- 숫자나 날짜를 문자열로 변환
ex)TO_CHAR(TO_DATE(20170101),'YYYYMMDD') 17/01/01=>20170101
ex)TO_CHAR(TO_DATE(20170101),'YYYY/MM/DD') 17/01/01=>2017/01/01
EX)TO_CHAR(SYSDATE, 'YYYYmmddHH24MISS') 20180525154110

12.TO_DATE() - 문자를 날짜로 변환
ex)TO_DATE(20170101)=> 17/01/01 년,원,일 출력

12-1.TO_NUMBER() - 문자를 숫자로 변환

13.TRIM(LTRIM,RTRIM) - 공백없애기
ex)select rtrim('asdfa','a') from dual => asdf (왼쪽<-오른쪽으로 한번만지움)
ex)select ltrim('asdfa','a') from dual => sdfa (왼쪽->오른쪽으로 한번만지움)
ex)TRIM('  asdf  ') => 'asdf' 

14.REPLACE() - 문자열 일부 변환
EX)select replace('010-5525-4256','-') from dual => '01055254256' (-가 나오면 제거해버림)
ex)select replace('010-5525-4256','-','z') from dual => '010z5525z4256' (-가 나오면 z로 변환해버림)

15.UPPER,LOWER - 대소문자 변환
ex)UPPER('asdf')=>'ASDF'
	 LOWER('ASDF')=>'asdf'
	 
16.CASE WHEN THEN - SELECT CASE문
EX)SELECT A.WH_CD,A.ORD_NO,
        CASE
          WHEN A.UNIT_WGT(컬럼명) >= 30 THEN 'A'
          WHEN A.UNIT_WGT(컬럼명) >= 20 THEN 'B'
          ELSE 'C'
        END
          AS 실적평가
  FROM WMS_ETC_DTL(테이블명) A
  
16'.CASE WHEN THEN - WHERE CASE문
EX)SELECT *
	 FROM  TPL_HBLH A
	 WHERE A.CARGO_TYPE = (CASE WHEN A.IO_TYPE='I'  THEN '1' ELSE 'P' END)

17.SUBSTR(글자 자르기 OR 글자 추출 or 문자열 자르기)
EX)SELECT SUBSTR('ABCD', 1,3) -- (1)첫번째 자리에서 (5)다섯번째 자리까지 가지고 오기 =>'ABC'
	 FROM DUAL;

	 SELECT SUBSTR('ABCD', -1) -- (-)맨 뒤에서 (1)자리수 가지고 오기 =>'D'
	 FROM DUAL; 
	 
18.IS NOT NULL - NULL 이 아닌값을 말한다. // IS NULL - NULL인 값을 말한다.  
EX)SELECT *
	 FROM WMS_ETC_DTL A
	 WHERE A.CNTR_NO IS NOT NULL - 조건이 CNTR_NO값이 NULL이 아닌값만 출력하라는 말
	 
19.부등호 = , <> AND !=
  = 는 같다.
  <>,!=는 같지않다.
  
20. IN
EX)SELECT *
	 FROM WMS_ETC_DTL A
	 WHERE A.SKU_NM IN ('냉동새우','동태L') 여러 컬럼값중 하나만이라도 일치하면 SELECT 할수있도록 도와준다.
	 
	 NOT IN 하면 반대로
	
21.CHR -다음줄로 넘어갈때 쓰는 방식(Enter key)
EX)SELECT REPLACE(SKU_CD,'-',CHR(13)||CHR(10))
	 FROM WMS_ETC_DTL A
	 WHERE A.SKU_NM IN ('냉동새우','동태L')

23.USING(ON과 비슷한 방식)
	 USING (WH_CD,ORD_NO); = ON A.WH_CD = B.WH_CD AND A.ORD_NO=B.ORD_NO;

24.IF-ELSE
-생략

25.RANK() OVER AND ROW_NUMBER()-순번매기기 

1)RANK() OVER - EX)SELECT GI_NO,PKUP_YMD, RANK() OVER(ORDER BY PKUP_YMD DESC) RANK  		=> (50,40,40,30,20)->1,2,2,4,5
							   	 FROM WMS_GI_MST

2)ROW_NUMBER()  EX)SELECT GI_NO,PKUP_YMD, ROW_NUMBER() OVER(ORDER BY PKUP_YMD DESC) RANK=> (50,40,40,30,20)->1,2,3,4,5
								   FROM WMS_GI_MST
								  
1')RANK() - RANK() OVER (PARTITION BY A.HBL_NO ORDER BY SUM(CNTR_WGT) DESC) RANK
2')ROW_NUMBER() - ROW_NUMBER() OVER (PARTITION BY A.HBL_NO ORDER BY SUM(CNTR_WGT) DESC) RANK								  								 
								 
								 ex)숫자           : 10,20,30,40,40,50
										RANK()         :  1,2,3,4,4,6
										DESEN_RANK()   :  1,2,3,4,4,5
										ROW_NUMBER()   :  1,2,3,4,5,6
								 
EX)
SELECT A.HBL_NO,A.MBL_NO,A.CNTR_SEQ,A.CNTR_NO,A.CNTR_WGT  
  FROM (  
    SELECT A.HBL_NO,A.MBL_NO,B.CNTR_SEQ,B.CNTR_NO,B.CNTR_WGT  
          ,ROW_NUMBER() OVER (PARTITION BY A.HBL_NO ORDER BY SUM(CNTR_WGT) DESC) RANK  
      FROM FMS_HBL_MST A  
          ,FMS_HBL_CNTR B  
     WHERE A.HBL_NO = B.HBL_NO  
    ) A  
WHERE RANK = 1  
ORDER BY A.HBL_NO,A.CNTR_NO

**맥스값 하나씩만 가지고오기
ROW_NUMBER()OVER(PARTITION BY A.CUST_CD ORDER BY A.INS_YMD DESC) RN
								 
26.ROUND() AND TRUNC()
ROUND() - EX)SELECT ROUND(2345.12) FROM DUAL => 2345 & SELECT ROUND(2345.62) FROM DUAL => 2346 - 반올림
TRUNC() - EX)SELECT TRUNC(12345.55,-2) FROM DUAL 소숫점 기준 -2칸 함 +2면 소수점 뒤로 두칸까지 나타냄 XXX.00

27.XMLTYPE()
-생략

28.DECLARE (TO_CLOB=>문자 대형 객체 //참조:http://orderby.tistory.com/entry/Oracle-%EB%8C%80%ED%98%95-%EB%8D%B0%EC%9D%B4%ED%84%B0%ED%98%95BLOB-CLOB-LOB-NCLOB-BFILE%EA%B3%BC-Java-%EC%98%88%EC%A0%9C)
-생략
CLOB - 대용량 저장소(4GB)

29.COMMIT
-생략

30.LENGTH()
ex)select length('asdf') from dual; => 4

31.cont :=
-생략

32.BETWENN
EX)WHERE A.ACCM_ACCT_CD BETWEEN 701900 AND 702500 // 701900~702500 사이의 숫자값을 조건으로함

33.Table 복사
ex)CREATE TABLE 테이블명 AS SELECT FROM 기존테이블 WHERE 1=2

--테이블 컬럼만 가지고올경우--
EX)CREATE TABLE BUYING_CLOSING_SERP AS SELECT * FROM ELVIS_ABC.BUYING_CLOSING_SERP WHERE 1=2

--테이블 컬럼 통채로 복사할경우--
EX)CREATE TABLE BUYING_CLOSING_SERP AS SELECT * FROM ELVIS_ABC.BUYING_CLOSING_SERP

34.다른 DBLink 타기
!데이터 링크를 걸때 해당 Toad 주소서버 안에있는 tnsname을 따라간다(내 컴퓨터 아님)

35.OVER()에 사용되는 OPTION
1.PARTTITION BY
2.ORDER BY DESC
3.NULLS FIRST : NULL 데이터 먼저 출력.
4.NULLS LAST : NULL데이터를 나중에 출력.

36.날짜형식 참고:http://aljjabaegi.tistory.com/18  

SELECT TO_DATE('20170101') AS TO_DATE -- 날짜형으로 변환
--          , ADD_MONTHS('20170101',1) --한달 더하기  EX)2017-02-05
--         , ADD_MONTHS(SYSDATE,1) -- 현재날짜에서 한달 더하기 EX)2017-02-05 오후 6:00:01
--         , LAST_DAY('20170106') -- 현재달 마지막날 EX) 2017-01-31
--         , LAST_DAY(SYSDATE) --요번달 마지막날 EX) 2017-01-31 오후 5:10:44
--         , TO_DATE(LAST_DAY(SYSDATE),'YY-MM-DD') --년원일만 뽑아낼때 EX)2017-01-05
--         , (TO_DATE('20170131')+1) -- 하루더할때  EX)2017-02-01
--------------------------------------------------------------------------------------------          
--          , (LAST_DAY(ADD_MONTHS(SYSDATE,-1))+1) --현재날짜 기준월초(시간포함) EX) 2017/01/01 몇시 몇분
--          , LAST_DAY(SYSDATE) --현재날짜 기준월말(시간포함) EX)2017/01/31 몇시 몇분..
--          
--         ,TO_DATE( (LAST_DAY(ADD_MONTHS(SYSDATE,-1))+1),'YY-MM-DD') --현재날짜 기준월초(년월일만) EX)2017/01/01
--         ,TO_DATE(LAST_DAY(SYSDATE),'YY-MM-DD') --현재날짜 기준월말(년월일만) EX)2017/01/31
--          
--         ,TO_CHAR(TO_DATE( (LAST_DAY(ADD_MONTHS(SYSDATE,-1))+1),'YY-MM-DD'),'YYYYMMDD')--현재날짜 기준월초(년월일만) EX)20170101 
--         ,TO_CHAR(TO_DATE(LAST_DAY(SYSDATE),'YY-MM-DD'),'YYYYMMDD') --현재날짜 기준월초(년월일만) EX)20170131

FROM DUAL

======================================================================================================================================================
select to_char(add_months(sysdate,-1),'yyyy-mm-dd'),-- 한달전 오늘
to_char(add_months(sysdate,-12),'yyyy-mm'),
to_char(add_months(sysdate,-12),'yyyy-mm-dd'), -- 1년전 오늘
to_char(add_months(sysdate,-12),'yyyy'),
to_char(sysdate-1,'yyyy-mm-dd') -- 어제
from dual

-오전,오후 스트링 변환하기
SELECT TO_CHAR(TO_DATE('2017-11-30 오후 4:42:37','YYYY-MM-DD AM HH:MI:SS'),'YYYYMMDDHH24MISS') FROM DUAL
SELECT TO_CHAR(TO_DATE(D.INS_YMD || D.INS_HM,'YYYYMMDDHH24MISS'),'yyyy-mm-dd AM hh:mi:ss') FROM DUAL
DATE 형식일경우 바로가지고 오면 이런현상발생
TO_CHAR(POD_UPD_DATE,'YYYY-MM-DD AM HH:MI:SS') 로 변환해준다.

37.문자열 합치기
'abc' || 'bcd' = 'abcbcd'

38.LIKE
SELECT *
FROM  TPL_HBLH A
WHERE A.ETD_DT LIKE '200%' - 200으로 시작되는 모든데이터
;
39.

가.SELECT()============================================================================================================================================

1.from->(select->where)->group by ->having ->order by(SELECT 예시)
ex)SELECT 보고싶은 컬럼명
	 FROM 테이블명
	 WHERE 조건문/GROUP BY (묶을 컬럼명), HAVING (조건문)
	 ORDER BY 정렬기준 컬럼명 // ORDER BY DESC 내림차순  ASC , 안썻을경우 오름차순
	 
나.Update()===========================================================================================================================================

ex)UPDATE 테이블명
   SET 업데이트 부분
	 WHERE  조건문
	 
다.Delete()===========================================================================================================================================

ex)DELETE 테이블명
	 WHERE 조건문
	 
라.Insert()===========================================================================================================================================
 INSERT INTO FMS_HBL_PRT_LOG (
	 CND_HBL_NO  
	,MNGT_NO

)
VALUES (
	'@CND_HBL_NO'
	,'@MNGT_NO'

ex)INSERT INTO 테이블명 () VALUES ()

마.ALTER==============================================================================================================================================
참조:http://blog.naver.com/logi96/126989529

-ALTER TABLE을 이용한 COLUMN 추가
1)ALTER TABLE 테이블명 ADD(컬럼명 데이터타입)
2)ALTER TABLE 테이블명 ADD(컬럼명 데이터타입 default디폴트값)

-ALTER TABLE을 이용한 COLUMN 변경
1)ALTER TABLE 테이블명 MODIFY(컬럼명 데이터타입)

-ALTER TABLE을 이용한 COLUMN 삭제

바.단축키==============================================================================================================================================

주석 : Ctrl + B
주석 해제 : Ctrl + Shift + B
컬럼목록표시:Ctrl + T (자동완성리스트)
현재 커서 SQL문 실행:Ctrl+Enter (Shift + F9)
대/소문자 변환:CTRL+L(소문자로) CTRL+R(대문자로)
ALT + Up
ALT + Down
DESC : F4
전체실행 : F5
현재 쿼리만 실행 : SHIFT + F9
그리드 보이게 실행 : F9
대문자:Ctrl+U
소문자:Ctrl+L
----

SQL EDITOR상에서의 편리한 단축키 
ESC: 열린 윈도우 닫기 
F1: 모든 단축키를 보여준다. 
F2: FULL SCREEN 
F4: Table, View, Proc, Funct, Package를 DESC(테이블명에 커서를 둔 상태에서 해야함) 
F6: SQL Editor와 결과창간의 전환
F7: 화면을 모두 CLEAR 
F8: 실행했던 SQL들의 HISTORY 
F9: 모든 쿼리 실행(Ctrl+Enter는 현재 쿼리만 실행) 
Ctrl+F9: 쿼리 저장할때
Ctrl+T : Columns Dropdown  (해당테이블의 컬럼목록 표시) 


**---------------------------------------------------------------------------DB복사 중요
1)DB 언어확인 - select * from v$nls_parameters;  //양쪽다 UTF8 맞는지 확인 필
2)DB 버전확인 - SELECT * FROM v$version; // 
3)DB덤프뜰때 => database-export-export utility(user선택->next(static:None설정)->next->경로지정->확인) //백업
4)DB덤프받을때 => database-import-import utility(user선택->next->next->from~to 선택->확인)
5)Db데이터 날릴때는 전체 드래그해서 delete 하면됨 대신 DBLink ,Type은 지우면 안됨 Function 등은 지워도 괜찮음 
5')User계정 새로 추가해야됨(ELVIS_ICSK,ELVIS_ICSK)
6)DB링크는 안주우는게 나음 조심!!
7)ELVIS(ELVIS_SYS,ELVIS_SYS)->ELVIS_ICSK
8)Publish로 생성한 파일을 Webapp-WCF에다가 집어넣어줘야함
10)서버에 IIS설정해야됨
11)설정후 폴더안에다가 Webapp파일 통으로 넣으면된다.

**새테이블만들때
CREATE TABLE 새로운테이블명
AS
SELECT * FROM 기존테이블

**테이블에 갑넣을때
INSERT INTO 테이블(받을테이블) SELECT * FROM 테이블(보낼테이블)

EX:
INSERT INTO MDM_OFFICE_MAND (OFFICE_CD,PGM_ID,ITEM_CD,ITEM_NM,MAND_YN,DFT_DAY) SELECT A.OFFICE_CD
     , 'TMSORD13MGT' AS PGM_ID
     , A.ITEM_CD
     , A.ITEM_NM
     , A.MAND_YN
     , A.DFT_DAY
  FROM MDM_OFFICE_MAND A
 WHERE 1=1
   AND A.OFFICE_CD = 'ABCHQ'
   AND A.PGM_ID = 'TMSORD07MGT'
 ORDER BY A.OFFICE_CD, A.PGM_ID, A.ITEM_CD
02.02------------------------------------------------------------------------------------------------------
--ExpBarEvt@Merge
MERGE INTO  FMS_TPL_TRACING A
    USING ( SELECT  '@EVT_CD' AS EVT_CD, '@HBL_NO' AS HBL_NO  FROM DUAL ) B
    ON (A.EVT_CD = B.EVT_CD AND A.HBL_NO = B.HBL_NO)
    WHEN MATCHED THEN 
              UPDATE SET   A.EVT_ACT_DT = TO_CHAR(CURRENT_TIMESTAMP,'YYYYMMDDHH24MISSFF')
     WHEN NOT MATCHED THEN 
            INSERT ( 
	        HBL_NO
	      , EVT_CD
	      , EVT_ACT_DT
	      , EVT_PORT_CD
	      , EVT_PORT_NM
	      , EVT_RMK
	      , ACT_RECVNM
	      , ACT_DELNM
	      , ACT_DELTEL_NO
	      , SEND_DT
	      , SEND_CHK
	      , INS_USR
	      , INS_YMD
	      , INS_HM
	      , UPD_USR
	      , UPD_YMD
	      , UPD_HM
	      )
   VALUES ( '@HBL_NO'
          , '@EVT_CD'
          , TO_CHAR(CURRENT_TIMESTAMP,'YYYYMMDDHH24MISSFF')
          , '@EVT_PORT_CD'
          , '@EVT_PORT_NM'
          , '@EVT_RMK'
          , '@ACT_RECVNM'
          , '@ACT_DELNM'
          , '@ACT_DELTEL_NO'
          , '@SEND_DT'
          , '@SEND_CHK'
          , '@INS_USR'
          , UFN_DATE_FORMAT('DATE')		
          , UFN_DATE_FORMAT('TIME')
          , '@INS_USR'
		  	  , UFN_DATE_FORMAT('DATE')		
          , UFN_DATE_FORMAT('TIME')
          )
          
         
2.EXISTS
EXITS 쿼리가 하나라도 존재할때 TRUE가 됨 
SELECT 'asdf' AS A FROM DUAL 
WHERE EXISTS(
SELECT 'asdf' AS A FROM DUAL)
-하나의 로우가 존재하기때문에 EXISTS는 TRUE가 된다.

3.UNION-중복제거합집합 / UNION ALL-중복포함합집합 / INTERSECT-교집합 / MINUS-차집합

4.coalesce
 NULL이 나올경우 계속넘어간다음 그다음값 출력
select coalesce(NULL,NULL,30,40) from dual 일경우 값은 30이 출력된다. => 30

5.initcap
 첫글자만 대문자로 바꿔주는 함수
 select initcap('babo') from dual => Babo

6.reverse
 문자열 거꾸로 출력
 select reverse('babo') from dual  => obab
 
 7.LPAD , RPAD (고정크기값으로 넣어야 할 경우 빈값채워넣기좋을듯)
 남는자리에 뭘넣을지 정하는 함수
select lpad('oracle',10,'x') from dual => xxxxoracle
select rpad('oracle',10,'x') from dual => oraclexxxx

*8.WMCONCAT (그룹묶은 나머지가 숫자일경우에는 SUM,AVERAGE 등등 쓰면되고 문자열은 WM_CONCAT 쓰면될듯) or LISTAGG-WITHIN
문자열합치는 함수 
select A, B
FROM(
SELECT '1' AS A , 'a' AS B FROM DUAL
UNION 
SELECT '1' AS A , 'b' AS B FROM DUAL)

EX)A B -컬럼
	 1 A
	 1 B
	
select A, WM_CONCAT(B) 
FROM(
SELECT '1' AS A , 'a' AS B FROM DUAL
UNION 
SELECT '1' AS A , 'b' AS B FROM DUAL)
GROUP BY A;

EX)A B -컬럼
	 1 A,B

*LISTAGG-WITHIN
LISTAGG(MSIZE,',') WITHIN  GROUP (ORDER BY SO_NO,SO_SEQ)

**문자열합치기(정렬가능 구문값 변경가능) - LISTAGG
SELECT TRMS_DOC_NO,LISTAGG(DOC_TYPE,'-+-') WITHIN GROUP(ORDER BY DOC_TYPE DESC) AA
  FROM FMS_EDI_MST 
  GROUP BY TRMS_DOC_NO
  
**ORACLE에서 MSSQL TOP1 처럼 사용할때
서브쿼리 -> ORDER BY , ROWNUM =1 하면 에러남 정렬불가능 MAX - KEEP을 사용하자

SELECT MAX(MNGT_NO) KEEP(DENSE_RANK FIRST ORDER BY TRMS_REQ_YMD DESC)
  FROM FMS_EDI_MST
  WHERE TRMS_REQ_YMD >= '20180101'
  AND DOC_TYPE ='SOMFC'


9.like
like '%' , like '_'
%는 모든문자 
_는 아무글자나 반드시 글자1개

10.escape 와일드카드 문자인 '_' , '%'가 포함된 데이터를 추출하고 싶을 때 사용함 ~생략

11.translate 특정문자제거  - replace랑 비슷한듯
select translate('a1b2c3d4f5g6','a1b2','asdf') from dual 'a1b2'가 나오면 'asdf'로 변환한다.

12.commit후 데이터복구  *row 1줄만 복구할수있을듯

ex)select * from FMS_TPL_TRACING AS OF TIMESTAMP(SYSTIMESTAMP-INTERVAL '30' MINUTE) - 30분 전 값을 조회할수있음

ex)
insert into FMS_TPL_TRACING
select * from FMS_TPL_TRACING AS OF TIMESTAMP(SYSTIMESTAMP-INTERVAL '30' MINUTE) where EVT_CD='13' - 특정조건만족하는 로우를 입력시키는 방법

13.MERGE 샘플
MERGE INTO TABLE_NAME A
    USING ( SELECT 'A' AS A , 'B' AS B, 'C' AS C FROM DUAL ) B
    ON (A.A=B.A AND A.B=B.B AND A.C=B.C) 
    WHEN MATCHED THEN 
--조건을 만족했을때              
     WHEN NOT MATCHED THEN 
--조건을 만족 못 했을 때

14.OFFICE_CD - PK (MDM_USER_MST 에 계정별로 OFFICE_CD가 지정되어있다.)
	
	=>MDM_USER_AUTH - 계정별 권한관리(USR_ID) 
	=>MDM_GRP_AUTH  - 계정그룹별 관리(GRP_ID) GRP_ID=AUTH_TYPE  // GRP_ID + MDM_USER_AUTH로 적용되는듯
	=>MDM_USER_MST  - 각 로그인 계정관리(OFFICE_CD,AUTH_TYPE)
	=>MDM_OFFICE_BANK - 계좌정보(OFFICE_CD) 등등 대부분 OFFICE_CD로 관리한다.

15.데이터베이스 전체이해
Cursor 구문을 분석한 후 임시 저장소나 메모리에 저장하는 데, 메모리 영역을 커서라고한다.
*Tables
**Views
***Synonyms 생략
1)Functions
값을 계산하고 결과값을 반환하기 위해서 함수를 많이 사용 한다.
프로그램 코드를 논리적으로 구성한 것/ 프로시저는 많은 양의 정보를 처리하지만 함수는 하나의 값을 Return한다.

2)Procedures(참고:http://www.gurubee.net/lecture/1041)
특정작업을 수행하는, 이름이 있는 PL/SQL BLOCK 이다.
매개 변수를 받을 수 있고, 반복적으로 사용 할 수 있는 BLOCK 이다.
보통 연속 실행 또는 구현이 복잡한 트랜잭션을 수행하는 PL/SQL BLOCK을 데이터베이스에 저장하기 위해 생성 한다.
ex)연속실행,구현이 복잡한 트랜잭션을 수행하는 PL/SQL BLOCK을 데이터베이스에 저장하기 위해 생성한다.

3)Packages
함수들의 집합

4)Triggers = Trigger 는 해당 테이블에 CRUD 연산을 처리할 때, DB 레벨에서 부가 작업을 할 수 있게 해 줍니다.

CREATE TRIGGER 트리거명 
AFTER INSERT OR UPDATE -- INSERT or UPDATE or DELETE 선택에 따라 해당 이벤트 발생시 트리거 실행됨
                                        -- AFTER : 트리거를 발생시키는 문장이 실행 후 트리거 실행됨
                                        -- BEFORE : 트리거를 발생시키는 문장이 실행 전 트리거 실행됨
 ON 이벤트발생대상테이블명 
 REFERENCING NEW AS NEW OLD AS OLD 
 
FOR EACH ROW
DECLARE 
 L_MSG_CODE VARCHAR2(100); -- 변수 선언
 L_MSG_NAME VARCHAR2(100); -- 변수 선언
 
BEGIN

--   여기서 해당 이벤트 발생시 진행할 업무 코딩~
--   프로시저 호출해도 되고 
--   해당 테이블 값은 NEW.필드명 으로 사용

END;

5)Indexes
6)Constraints
7)Sequences
8)Java
9)DB Links
10)Users
11)Jobs
12)Types
13)Queue Tables
14)Queues
15)Directories
16)Policy Groups
17)Profiles
18)Policies
19)Rollback Segments
20)Tablespaces
21)Libraries
22)Materialized Views
23)Roles
24)Favorites
25)Materialized View Logs
26)Dimensions
27)Resource Groups
28)Resource Plans
29)Sys Privs
30)Clusters
31)Refresh Group
32)Recycle Bin
33)Sched. Chains
34)Sched. Programs
35)Sched. Schedules
36)Sched. Jobs
37)Sched. Job Classes
38)Sched. Windows
39)Sched. Window Groups
40)Invalid Objects
41)Contexts
42)Flashback Archives 
43)Transformations

-PK 존재하는것들 제외한 나머지만 SKU_MST안에다가 데이터 넣기(NOT EXISTS- 존재하지않으면 TRUE )
INSERT INTO SKU_MST (SYS_NO, NA_NO, SKU_SID, VENDOR_NO, SKU_YYMM, SKU_NO, SKU_GNO, RATE_UNIT, RATE_QTY_UNIT, RATE_LOC, RATE_OVER, RATE_OVER_CUR, ADD_USERID, ADD_DATE) 
SELECT * --COUNT(*)  
  FROM CO_CUST_EXCEL_WEB_MOD A 
 WHERE NOT EXISTS (SELECT 1 FROM SKU_MST  
                           WHERE SYS_NO = A.SYS_NO  
                             AND NA_NO = A.NA_NO 
                             AND VENDOR_NO = A.VENDOR_NO 
                             AND VENDOR_NO = A.VENDOR_NO 
                             AND SKU_YYMM = A.SKU_YYMM  
                             AND SKU_NO = A.SKU_NO )
                             
EXISTS (SELECT 1 FROM LGD_SR_MST WHERE INVOICE_NO = B.DOC_NO)

-----------------------------------------golden 사용해서 엑셀(EXCEL)파일 DB에 업데이트 시키기------------------------------
--select * from CO_CUSTOMER_UP1 where Code LIKE 'AD86ES%';

-- golden 접속후 로그인한다음에 쿼리에  데이터넣어준다(예시)
--SELECT ROWID,a.*
--FROM CO_CUSTOMER_UP1 a

-----------------------------------------golden 사용해서 엑셀(EXCEL)파일 DB에 IMPORT 시키기------------------------------2018/06/12

참조:http://gent.tistory.com/23
http://gent.tistory.com/32
1.엑셀을 컬럼,데이터 형식으로 데이터 만든 후 CSV로 저장한다.
--EX)ELVIS_MCI/MCI!#%&/MCI.ELVIS.COM 사용

2.로그인

1)TOOLS->DATA IMPORT/EXPORT

2)IMPORT 탭

3)SORUCE FILE 에 엑셀 올리고 DESTINATION TABLE 에 ELVIS_MCI.테이블명 넣고 임포트하면됨

--db백업
CREATE TABLE CO_CUSTOMER_20170224
AS
SELECT * FROM CO_CUSTOMER

SELECT COUNT(*) FROM CO_CUSTOMER_UP1 ;

SELECT * FROM CO_CUSTOMER_UP1 WHERE CODE =  'AD86ES';
SELECT * FROM CO_CUSTOMER WHERE CODE =  'AD86ES';

UPDATE CO_CUSTOMER_UP1 A
   SET A.CODE=TRIM(CODE)
        , A.POWERNET_ID=TRIM(POWERNET_ID)
     WHERE  1=1;
     
-- 2267     
SELECT COUNT(*) FROM CO_CUSTOMER A
WHERE EXISTS ( SELECT 1 FROM CO_CUSTOMER_UP1 WHERE CODE = TRIM(A.CODE) )     

SELECT A.CODE,A.POWERNET_ID,B.POWERNET_ID--, TO_NUMBER(TRIM(A.POWERNET_ID)) - TO_NUMBER(TRIM(B.POWERNET_ID)) CHAI
  FROM CO_CUSTOMER A
          ,CO_CUSTOMER_UP1 B
 WHERE TRIM(A.CODE ) = TRIM( B.CODE)
  AND TRIM(A.CODE) = 'QS34ES'
ORDER BY A.POWERNET_ID
     
MERGE INTO  CO_CUSTOMER A
    USING ( SELECT *  
                  FROM CO_CUSTOMER_UP1  )  B
    ON (TRIM(A.CODE)=TRIM(B.CODE)) 
    WHEN MATCHED THEN 
              UPDATE SET   A.POWERNET_ID=TRIM(B.POWERNET_ID)
     WHEN NOT MATCHED THEN 
            INSERT  ( CODE  , POWERNET_ID    )
             VALUES
                    (TRIM(B.CODE),TRIM(B.POWERNET_ID) )
                    
*컬럼 데이터형(ALTER)수정할때는 테이블 더블클릭 또는 우클릭해서 Alter Table클릭으로 들어가서 수정하면된다.

SELECT TRIM(B.WH_Nm) WH_NM
FROM
(
SELECT A.*,ROW_NUMBER() OVER(ORDER BY WH_NM ASC) RANK FROM MDM_WH_MST A WHERE WH_NM LIKE '(주)%'
)B
WHERE B.RANK<=10

데이터 일부만 추출하기~

SessionInfo.UserID.ToString & ""

, UPD_USR 		= '@USR_ID'
, UPD_YMD	  	= UFN_DATE_FORMAT('DATE')     
, UPD_HM	  	= UFN_DATE_FORMAT('TIME')

백업
SELECT CUST_NM,LOC_NM,INS_YMD
FROM
(SELECT A.CUST_NM
	  ,B.LOC_NM
	  ,TO_DATE(A.INS_YMD) AS INS_YMD
FROM TMS_BIZ_DIARY_MST A, MDM_USER_MST B
WHERE A.INS_USR=B.USR_ID) A
WHERE A.CUST_NM LIKE '@CUST_NM%'
  AND A.LOC_NM LIKE '@LOC_NM%'
[DATE_SEARCH]
	   AND A.INS_YMD>'@DATE_FM'
	   AND A.INS_YMD<'@DATE_TO'
[/DATE_SEARCH]

 							, INS_USR             
			        , INS_YMD            
			        , INS_HM
			        , UPD_USR
			        , UPD_YMD            
			        , UPD_HM
			        , '@USR_ID'
			        , UFN_DATE_FORMAT('DATE')        
			        , UFN_DATE_FORMAT('TIME')
			        , '@USR_ID'
			        , UFN_DATE_FORMAT('DATE')        
			        , UFN_DATE_FORMAT('TIME')
			       
*데이터 임의로 넣고 서치할때 안될경우 commit 해줘야함.			       


**NVL 
SELECT NVL(MAX(CAR_SEQ),0)+1
               FROM TMS_SO_ALOC_MST 
              WHERE SO_NO = 'LE2017031500001' 
              
              
**rownum oracle 첫번째줄 값만 가지고오기
where rownum=1

**Combobox databinding(데이터바인딩 콤보박스)
 CUST_CD.DataSource = ds.Tables("Data.ComboList")
            CUST_CD.DisplayMember = "CUST_NM"
            CUST_CD.ValueMember = "CUST_CD"
            
db덤프: http://blog.naver.com/heeskeg/40191964418 

If dt.Rows.Count = 0 Then
                    ThrowMsg(ErrorOccur, "Data not found!")
                End If
                
*oracle 덤프 빈테이블 안떠질때 
--> ALTER SYSTEM SET DEFERRED_SEGMENT_CREATION=FALSE SCOPE=BOTH; 
-- 빈테이블일때 EXP 안된다. 위의명령어 실행. 
-- 그이후 만들어진 테이블에만 적용됨. 

*ORACLE 덤프 설정변경
--> SELECT 'ALTER TABLE '||table_name||' ALLOCATE EXTENT;' FROM user_tables WHERE segment_created = 'NO'; 
-- 해당계정으로 들어가서 실행하면 실행문이 나온다 이거 전체 결과 CTRL+C 해서 CTRL+V 해서 F5눌러서 해주면됨
-- 이걸로 테이블 변경하고 EXP 받으면 된다.

*날짜포맷 맞추기
TO_CHAR(TO_DATE(UPD_YMD),'YYYY-MM-DD' || ')')) NAME //EX)UPD_YMD=20170101

to_char(to_date(D.INS_YMD || D.INS_HM,'YYYYMMDDHH24MISS'),'yyyy-mm-dd hh24:mi:ss') INS_DATE

EX) ASP_SDATETIME = '20161026170148'
TO_DATE(ASP_SDATETIME,'yyyy-mm-dd hh24:mi:ss')

 TO_CHAR(TO_DATE('20170101'),'YYYY-MM-DD')

오늘날짜 가지고오기 SELECT TO_CHAR(TO_DATE(UFN_DATE_FORMAT('DATE')),'YYYY-MM-DD') A FROM DUAL


*원하는문자열 모두 빼버리기
select TRIM(TRANSLATE('302-55152-4441-22 가나은행', '0123456789-', '          ')) from dual 

UPDATE MDM_CUST_OTH A
      SET A.CLOSE_TYPE = (SELECT CLOSE_TYPE FROM MDM_CUST_OTH_TEMP_2 WHERE CUST_CD=A.CUST_CD)
 WHERE A.CLOSE_TYPE IS NULL
ß
*원하는순서 ORDER BY
 (CASE WHEN CODE LIKE 'G%' THEN 1 WHEN CODE LIKE '%' THEN 2 END)
 
*랭크걸어서 최신데이터 1건씩만 가지고오게

SELECT A.USERID,A.DLV_X_POING,A.DLV_Y_POING,C.LISENCE_NO,C.CUR_DRV_NM,TO_CHAR(INS_DT,'MM/DD HH24:MI') INS_DT,ROW_NUMBER()OVER(PARTITION BY A.USERID ORDER BY A.INS_DT DESC) RN 
  FROM MOBILE.APP_GPS A , MDM_EXT_USR_AUTH_MST B , TMS_CAR_MST C 
WHERE A.USERID=B.USR_ID AND B.AUTH_CD=C.CAR_NO
ORDER BY A.USERID

*중복데이터 있을경우 -1 붙여주기

SELECT NVL((
SELECT (CASE WHEN REPLACE(HBL_NO,'-1','')='@HBL_NO' THEN HBL_NO 
             ELSE (SELECT DECODE((MAX(HBL_NO)||'-1'),'-1','@HBL_NO',(MAX(HBL_NO)||'-1')) HBL_NO FROM TMS_SO_MST WHERE HBL_NO = '@HBL_NO' OR HBL_NO LIKE '@HBL_NO'||'-1%') 
             END) HBL_NO 
  FROM TMS_SO_MST WHERE SO_NO='@SO_NO'),
  (SELECT DECODE((MAX(HBL_NO)||'-1'),'-1','@HBL_NO',(MAX(HBL_NO)||'-1')) HBL_NO FROM TMS_SO_MST WHERE HBL_NO = '@HBL_NO' OR HBL_NO LIKE '@HBL_NO'||'-1%'))HBL_NO FROM DUAL
  
  *테이블 백업
CREATE TABLE TMS_CAR_MST_171205 
AS 
SELECT * FROM TMS_SO_ALOC_MST


프로시저 WHERE문 조건 블록
where절

AND (((30 = A.QRY_RNG ) AND (A.REQ_DEPT LIKE '%'||''||'%'))

       OR ((10 = A.QRY_RNG  ) and (A.REQ_DEPT LIKE '%'||?||'%')))

 

위 구문을 풀이해보면


if (30 == A.QRY_RNG) {

   A.REQ_DEPT_LIKE '%'||''||'%'

}else if ( 10 == A.QRY_RNG) {

  A.REQ_DEPT_LIKE '%'||?||'%'

}

*(P_HBLMBLNO IS NULL) 빈값이면 조건문 안넣는것
예제1
AND (((P_ETDETA = 'ETD') AND (C.ETD_DT = REPLACE(P_PICKUPDT,'-',''))) OR ((P_ETDETA = 'ETA') AND (C.ETA_DT = REPLACE(P_PICKUPDT,'-',''))))
       AND ((P_HBLMBLNO IS NULL) OR ((P_HBLMBL = 'MAWB') AND (C.MBL_NO = P_HBLMBLNO)) OR ((P_HBLMBL = 'HAWB') and (C.HBL_NO = P_HBLMBLNO)))
       AND ((P_POLPODNO IS NULL) OR ((P_POLPOD = 'POL') AND (C.POL_CD = P_POLPODNO)) OR ((P_POLPOD = 'POD') AND (C.POD_CD = P_POLPODNO)))

예제2       
AND B.ORDERNO  = (SELECT SO_NO FROM IF_TMS_SO_MST WHERE (((MBL_NO IS NOT NULL) AND (MBL_NO = '73862611091' )) OR ((MBL_NO IS NULL) AND (SO_NO = '73862611091'))))

하나만 가지고오기
SELECT * FROM (SELECT A.*,ROW_NUMBER()OVER(PARTITION BY A.CUST_CD ORDER BY A.INS_YMD DESC) RN FROM MDM_CUST_BANK A) WHERE RN=1

(CREATE TABLE SELECT)
CREATE TABLE MDM_CUST_MST_20180604 AS SELECT * FROM MDM_CUST_MST;

(SELECT INSERT SELECT)
INSERT INTO MDM_LANG_NAME SELECT * FROM MDM_LANG_NAME_20180604 WHERE REQ_CD IN(SELECT OFFICE_CD FROM MDM_OFFICE_MST GROUP BY OFFICE_CD) 

-SELECT INSERT (INSERT SELECT) 운임 링크 깨진것 인서트
INSERT INTO ACT_INV_MST (
            OFFICE_CD
            ,INV_NO
            ,INV_YMD
            ,PERF_YMD
            ,DEPT_CD
            ,INV_TYPE
            ,DC_TYPE
            ,BAL_FCUR_AMT
            ,BAL_LOC_AMT
            ,RNPAY_FCUR_AMT
            ,RNPAY_LOC_AMT
            ,EXRT
            ,PL_CFRM
            ,BILG_CURR_EXRT
            ,TAX_CFRM
            ,SVC_TAX_AMT
            ,EDU_TAX_AMT
            ,SHE_TAX_AMT
            ,TDS_RATE
            ,TDS_TAX_AMT
            ,ADD_YN
            ,ADV_YN
            ,INS_USR
            ,INS_YMD
            ,INS_HM
            ,UPD_USR
            ,UPD_YMD
            ,UPD_HM
            )
SELECT OFFICE_CD
           ,INV_NO
           ,INS_YMD INV_YMD
           ,INS_YMD PERF_YMD
           ,'SYS0002' DEPT_CD
           ,'B' INV_TYPE
           ,'C' DC_TYPE
           ,0 BAL_FCUR_AMT
           ,'0' BAL_LOC_AMT
           ,0 RNPAY_FCUR_AMT
           ,0 RNPAY_LOC_AMT
           ,0 EXRT
           ,'N' PL_CFRM
           ,0 BILG_CURR_EXRT
           ,'N' TAX_CFRM
           ,0 SVC_TAX_AMT
           ,0 EDU_TAX_AMT
           ,0 SHE_TAX_AMT
           ,0 TDS_RATE
           ,0 TDS_TAX_AMT
           ,'N' ADD_YN
           ,'N' ADV_YN
           ,INS_USR
           ,INS_YMD
           ,INS_HM
           ,UPD_USR
           ,UPD_YMD
           ,UPD_HM
 FROM ACT_INV_DTL WHERE  INV_NO='TEMB17082171' AND ROWNUM=1
 
 EX)여러건 한번에 입력
 INSERT INTO ELVIS_ABC.MDM_CUST_CREDIT (OFFICE_CD, REQ_SVC, CUST_CD, CREDIT_TERM, PAY_TERM, RMK, CREDIT_TERM_BL, INS_USR, INS_YMD, INS_HM, UPD_USR, UPD_YMD, UPD_HM)
        SELECT 'TRS' OFFICE_CD, REQ_SVC, CUST_CD, CREDIT_TERM, PAY_TERM, RMK, CREDIT_TERM_BL, INS_USR, INS_YMD, INS_HM, UPD_USR, UPD_YMD, UPD_HM FROM ELVIS_ABC.MDM_CUST_CREDIT WHERE CUST_CD IN (SELECT A.CUST_CD FROM (SELECT B.CUST_CD FROM TMS_SO_MST A , ACT_INV_DTL B WHERE A.SO_NO=B.MNGT_NO(+) AND TRIM(B.CUST_CD) IS NOT NULL GROUP BY B.CUST_CD) A , (SELECT * FROM ELVIS_ABC.MDM_CUST_CREDIT WHERE OFFICE_CD='TRS') B
WHERE A.CUST_CD = B.CUST_CD(+) AND B.CUST_CD IS NULL)
 
 
 --전송오더 데이터 다른것들 맞춰줌
 SELECT A.MNGT_NO
           ,A.INV_NO
           ,A.CUST_CD
           ,A.CUST_NM
           ,B.TRAN_CD
           ,B.TRAN_NM
           ,A.FARE_CD
           ,A.FARE_NM
           ,A.FARE_SEQ
           , A.FARE_LOC_AMT FARE_LOC_AMT_B
           , (SELECT SUM(FARE_LOC_AMT) FROM ACT_INV_DTL WHERE MNGT_NO = A.MNGT_NO AND FARE_CD = A.FARE_CD AND SELL_BUY_TYPE ='S' ) FARE_LOC_AMT_S
  FROM ACT_INV_DTL A, TMS_SO_ALOC_MST B
WHERE A.MNGT_NO = B.SO_NO(+)
    AND A.MNGT_SEQ = B.SO_SEQ(+)
    AND A.INV_NO = B.INV_NO(+)
    AND A.MNGT_NO IN (SELECT SO_NO FROM ELVIS_TRS.TMS_SO_MST WHERE ROUTE_NO ='TRS' AND LOAD_REQ_DT BETWEEN '20171001' AND '20180116')  AND FARE_CD='TRK' AND CUST_CD <> '033934' AND MBL_HBL_TYPE='M' --AND SELL_BUY_TYPE ='B'
    --AND A.FARE_LOC_AMT <>(SELECT SUM(FARE_LOC_AMT) FROM ACT_INV_DTL WHERE MNGT_NO = A.MNGT_NO AND FARE_CD = A.FARE_CD AND SELL_BUY_TYPE ='S' )
    --AND B.TRAN_CD IS NOT NULL
    --AND A.MNGT_NO='LWE2017110300037'

UPDATE ACT_INV_DTL A
      SET A.CUST_CD ='033934'
            ,A.CUST_NM ='에이비씨트랜스'
WHERE A.MNGT_NO||A.INV_NO IN 
           (SELECT A.MNGT_NO||A.INV_NO
              FROM ACT_INV_DTL A, TMS_SO_ALOC_MST B
            WHERE A.MNGT_NO = B.SO_NO(+)
                AND A.MNGT_SEQ = B.SO_SEQ(+)
                AND A.INV_NO = B.INV_NO(+)
                AND A.MNGT_NO IN (SELECT SO_NO FROM ELVIS_TRS.TMS_SO_MST WHERE ROUTE_NO ='TRS' AND LOAD_REQ_DT BETWEEN '20171001' AND '20180116') AND FARE_CD='TRK' AND CUST_CD <> '033934' AND MBL_HBL_TYPE='M' AND SELL_BUY_TYPE ='B'
                --AND A.FARE_LOC_AMT <>(SELECT SUM(FARE_LOC_AMT) FROM ACT_INV_DTL WHERE MNGT_NO = A.MNGT_NO AND FARE_CD = A.FARE_CD AND SELL_BUY_TYPE ='S' )
                AND B.TRAN_CD IS NOT NULL)
           --AND FARE_CD='TRK' AND CUST_CD <> '033934' AND MBL_HBL_TYPE='M' AND SELL_BUY_TYPE ='B' 

UPDATE TMS_SO_ALOC_MST A
      SET A.TRAN_CD ='033934'
            ,A.TRAN_NM ='에이비씨트랜스'
WHERE A.SO_NO||A.INV_NO IN 
           (SELECT A.MNGT_NO||A.INV_NO
              FROM ACT_INV_DTL A, TMS_SO_ALOC_MST B
            WHERE A.MNGT_NO = B.SO_NO(+)
                AND A.MNGT_SEQ = B.SO_SEQ(+)
                AND A.INV_NO = B.INV_NO(+)
                AND A.MNGT_NO IN (SELECT SO_NO FROM ELVIS_TRS.TMS_SO_MST WHERE ROUTE_NO ='TRS' AND LOAD_REQ_DT BETWEEN '20171001' AND '20180116') AND FARE_CD='TRK' AND CUST_CD <> '033934' AND MBL_HBL_TYPE='M' AND SELL_BUY_TYPE ='B'
                --AND A.FARE_LOC_AMT <>(SELECT SUM(FARE_LOC_AMT) FROM ACT_INV_DTL WHERE MNGT_NO = A.MNGT_NO AND FARE_CD = A.FARE_CD AND SELL_BUY_TYPE ='S' )
                AND B.TRAN_CD IS NOT NULL)
                

**날자변수 :  set D=%DATE:-=%
               
--------------------------------오라클백업 명령어(데이터베이스)---------------------------------
풀 백업 : EXP USERID=SYSTEM/ORA2764 full=y file=d:\BACKUP\ORA11_EXP_%D%.dmp log=d:\BACKUP\ORA11_log_%D%.log

유저 백업(ELVIS_ABC) : EXP ELVIS_ABC/ELVIS_ABC FILE=E:\BACKUP_ABC\THU_EXP.DMP LOG=E:\BACKUP_ABC\THU_EXP.LOG
유저 백업(MOBILE) : EXP MOBILE/MOBILE FILE=E:\BACKUP_ABC\THU_EXP.DMP LOG=E:\BACKUP_ABC\THU_EXP.LOG                
                
--------------------------------오라클백업 명령어(클라이언트)---------------------------------

[계정백업 EXPORT]
exp 계정/아이디@tnsname owner=유저명 file=저장할 경로+파일명 log=저장할경로+파일명
exp SYSTEM/ORA2764@ABC.ELVIS.COM owner=MOBILE file=D:backup_mobile_20180208.dmp log=D:backup_mobile_20180208.log
또는
exp MOBILE/MOBILE@ABC.ELVIS.COM file=D:backup_mobile_20180208.dmp log=D:backup_mobile_20180208.log

[풀 EXPORT]
exp SYSTEM/ORA2764@ABC.ELVIS.COM full=y file=D:backup_mobile_20180208.dmp log=D:backup_mobile_20180208.log
or
set D=%DATE:-=%
exp system/yjit108@ICSK.ELVIS.COM full=y file=D:\backup_108full_%D%.dmp log=D:\backup_108full_%D%.log

[계정백업 IMPORT] 
imp 계정/아이디@tnsname file=저장할 경로+파일명 FROMUSER=export받은 유저명  TOUSER=import시킬 유저명 ignore=y log=저장할경로+파일명
imp system/yjit108@ELVIS file=e:backup_ATLAS_20171227.DMP FROMUSER=ATLAS TOUSER=ATLAS ignore=y log=e:backup_ATLAS_20171227.log

---------------------------------------------------------------------------------------------------

[전체백업]
exp userid=system/manager file='C:\full.dmp' full=y
imp userid=system/system file='C:\full.dmp' full=y 

[사용자단위 백업]
exp userid=scott/tiger file='C:\scott.dmp' 
or
exp userid=system/manager owner=scott file='C:\scott.dmp' 

imp userid=system/manager owner=scott file='C:\scott.dmp' 

출처: http://fruitdev.tistory.com/40 [과일가게 개발자]
----------------------------------------------------------------------------------------------------
**** 참조 : http://dinggur.tistory.com/165
ABC 백업 예제

-EXP 이방법이 빠름(DB서버에 넣고 실행하면됨)- @ECHO OFF 하면 명령어는 안보임
@echo off
EXP ELVIS_SYS/ELVIS_SYS FILE=D:\ELVIS_SYS.DMP LOG=D:\ELVIS_SYS.LOG
EXP MOBILE/MOBILE FILE=D:MOBILE.DMP LOG=D:MOBILE.LOG
EXP ELVIS_TRS/ELVIS_TRS FILE=D:ELVIS_TRS.DMP LOG=D:ELVIS_TRS.LOG
EXP ELVIS_ABC/ELVIS_ABC FILE=D:ELVIS_ABC.DMP LOG=D:ELVIS_ABC.LOG
Exit

-IMP-


----------------------------------------------------------------------------------------------------

@echo off
EXP USERID=system/yjit108 full=y file=E:\OracleBackup\FULL_BACKUP.dmp log=E:\OracleBackup\FULL_BACKUP.log

IN NOT IN 같이 쓸경우 예시

SELECT * 
					  FROM ACT_INV_DTL   
					 WHERE FARE_LOC_AMT > 0  
					   AND (  (FARE_CD IN ('POD','POD0') AND 1=@FARE_CD_01 ) --도착보고비 
					    OR (FARE_CD IN ('SEC','SEC0') AND 1=@FARE_CD_02 ) --용역비  
					    OR (FARE_CD NOT IN ('TRK','TRK0','WCC','RTK','RTK0','CCHG','WAT','PKC','PKC0','POD','POD0','SEC','SEC0') AND 1=@FARE_CD_03 ))

--OR AND 조건

 MdmCustomerMgt@CheckLicenseNo 
SELECT CUST.CRN  
  FROM MDM_CUST_MST CUST 
 WHERE CUST.CRN = '@CRN' 
   AND  (('@CUST_CD' IS NULL) AND (1=1) OR ('@CUST_CD' IS NOT NULL) AND (CUST.CUST_CD <> '@CUST_CD')) --20180221 노진형 수정 
   --AND CUST.CUST_CD <> '@CUST_CD' [16
   
   
---트리거 로그

CREATE OR REPLACE TRIGGER ELVIS_ABC.UTR_TMS_SO_ALOC_MST 
      BEFORE UPDATE ON ELVIS_ABC.TMS_SO_ALOC_MST       FOR EACH ROW
BEGIN 
IF NVL(TO_CHAR(:OLD.LOAD_ST_HM),' ') != NVL(TO_CHAR(:NEW.LOAD_ST_HM),' ') THEN    INSERT INTO FMS_LOG_MST(MNGT_NO, LOG_YMD, WORK_USR_ID,FLAG,TABLE_NM,COL_NM,OLD_VAL, NEW_VAL,MBL_NO) VALUES (:NEW.SO_NO,SYSDATE,:NEW.UPD_USR,'U','TMS_SO_ALOC_MST','LOAD_ST_HM',:OLD.LOAD_ST_HM,:NEW.LOAD_ST_HM,:NEW.SO_NO ); END IF;
IF NVL(TO_CHAR(:OLD.ARR_PLAN_HM),' ') != NVL(TO_CHAR(:NEW.ARR_PLAN_HM),' ') THEN    INSERT INTO FMS_LOG_MST(MNGT_NO, LOG_YMD, WORK_USR_ID,FLAG,TABLE_NM,COL_NM,OLD_VAL, NEW_VAL,MBL_NO) VALUES (:NEW.SO_NO,SYSDATE,:NEW.UPD_USR,'U','TMS_SO_ALOC_MST','ARR_PLAN_HM',:OLD.ARR_PLAN_HM,:NEW.ARR_PLAN_HM,:NEW.SO_NO ); END IF;
IF NVL(TO_CHAR(:OLD.LOAD_PLAN_HM),' ') != NVL(TO_CHAR(:NEW.LOAD_PLAN_HM),' ') THEN    INSERT INTO FMS_LOG_MST(MNGT_NO, LOG_YMD, WORK_USR_ID,FLAG,TABLE_NM,COL_NM,OLD_VAL, NEW_VAL,MBL_NO) VALUES (:NEW.SO_NO,SYSDATE,:NEW.UPD_USR,'U','TMS_SO_ALOC_MST','LOAD_PLAN_HM',:OLD.LOAD_PLAN_HM,:NEW.LOAD_PLAN_HM,:NEW.SO_NO ); END IF;
IF NVL(TO_CHAR(:OLD.LOAD_HM),' ') != NVL(TO_CHAR(:NEW.LOAD_HM),' ') THEN    INSERT INTO FMS_LOG_MST(MNGT_NO, LOG_YMD, WORK_USR_ID,FLAG,TABLE_NM,COL_NM,OLD_VAL, NEW_VAL,MBL_NO) VALUES (:NEW.SO_NO,SYSDATE,:NEW.UPD_USR,'U','TMS_SO_ALOC_MST','LOAD_HM',:OLD.LOAD_HM,:NEW.LOAD_HM,:NEW.SO_NO ); END IF;
IF NVL(TO_CHAR(:OLD.UNLOAD_PLAN_HM),' ') != NVL(TO_CHAR(:NEW.UNLOAD_PLAN_HM),' ') THEN    INSERT INTO FMS_LOG_MST(MNGT_NO, LOG_YMD, WORK_USR_ID,FLAG,TABLE_NM,COL_NM,OLD_VAL, NEW_VAL,MBL_NO) VALUES (:NEW.SO_NO,SYSDATE,:NEW.UPD_USR,'U','TMS_SO_ALOC_MST','UNLOAD_PLAN_HM',:OLD.UNLOAD_PLAN_HM,:NEW.UNLOAD_PLAN_HM,:NEW.SO_NO ); END IF;
IF NVL(TO_CHAR(:OLD.UNLOAD_HM),' ') != NVL(TO_CHAR(:NEW.UNLOAD_HM),' ') THEN    INSERT INTO FMS_LOG_MST(MNGT_NO, LOG_YMD, WORK_USR_ID,FLAG,TABLE_NM,COL_NM,OLD_VAL, NEW_VAL,MBL_NO) VALUES (:NEW.SO_NO,SYSDATE,:NEW.UPD_USR,'U','TMS_SO_ALOC_MST','UNLOAD_HM',:OLD.UNLOAD_HM,:NEW.UNLOAD_HM,:NEW.SO_NO ); END IF;
IF NVL(TO_CHAR(:OLD.ARR_RPT_HM),' ') != NVL(TO_CHAR(:NEW.ARR_RPT_HM),' ') THEN    INSERT INTO FMS_LOG_MST(MNGT_NO, LOG_YMD, WORK_USR_ID,FLAG,TABLE_NM,COL_NM,OLD_VAL, NEW_VAL,MBL_NO) VALUES (:NEW.SO_NO,SYSDATE,:NEW.UPD_USR,'U','TMS_SO_ALOC_MST','ARR_RPT_HM',:OLD.ARR_RPT_HM,:NEW.ARR_RPT_HM,:NEW.SO_NO ); END IF;
END;
/

* 문자열 포함
INSTR(FILE_NM,'MyPhoto') 포함되면 0 반환 아니면 글자수 반환


========================================================================================================================================================================================

** 인덱스,뷰어,커서,클러스터링,

Hash Join ,Sort Merge Join, Nested-Loop Join

-----------------------
대용량 조인 - Hash Join + Parallel Processing

대용량아닐때 조인 - Nested-Loop Join(보통 조인해서 쓰는방법 선행테이블의 정보가 적을수록 성능이 높아짐)

 

---오라클 쿼리 튜닝---
** ORDER BY,GROUP BY 성능저하 (SORT 치명적)

1단계  조인할때 선행 집합에 신경을 써야함 (앞부분의 데이터가 적을수록 조인건수가 줄어들기때문)

2단계  A->B->C 에서 B보다 C에 적절한 인덱스가 존재할경우 A->C->B로 바꿔도 좋다







*WITH 구문 (테이블 두번 이상조회되는경우 사용하기)

WITH AAA
  AS 
  (
    SELECT '1' KEY,'BAE' AA FROM DUAL  
  )
  ,
  BBB
  AS 
  (
    SELECT '1' KEY,'ASDF' BB FROM DUAL  
  )
SELECT * FROM AAA.KEY=BBB.KEY

*

**INDEX 인덱스 조회

SELECT A.UNIQUENESS,
       B.*
  FROM ALL_INDEXES A,
       ALL_IND_COLUMNS B
 WHERE A.INDEX_NAME = B.INDEX_NAME
   AND A.TABLE_NAME=UPPER('TMS_SO_ALOC_MST');
   
**오라클 & SQL DB링크 COLUMN 조회

1)오라클
  SELECT *
  FROM ALL_TAB_COLUMNS
  WHERE TABLE_NAME='ACT_INV_DTL' AND OWNER = 'ELVIS_MCI'
  
2)DB링크
  SELECT * 
  FROM ALL_TAB_COLUMNS@DL_LGD
  WHERE TABLE_NAME='ActSellBuyMst' --대소문자 구분해야됨
   
   
1.영업사원 업무담당자 중복체크 쿼리  MDM_CUST_SALES , MDM_CUST_TASK_PIC

-> SELECT * FROM (SELECT A.*,ROW_NUMBER() OVER (PARTITION BY CUST_CD,OFFICE_CD,SO_MODE ORDER BY SO_MODE DESC) RANK FROM (SELECT CUST_CD,OFFICE_CD,SO_MODE FROM MDM_CUST_SALES) A) WHERE RANK =2


**컬럼이 포함되는 테이블 찾을때 사용하는 쿼리

SELECT OWNER,TABLE_NAME   
  FROM ALL_TAB_COLUMNS   
 WHERE OWNER IN ('ELVIS_ABC','ELVIS_TRS','MOBILE') --원하는 계정
   AND column_name = 'HBL_NO'   --원하는 컬럼
 GROUP BY OWNER,TABLE_NAME     
 ORDER BY OWNER,TABLE_NAME   
 
 
**문자열 자르기 

SUBSTR 문자갯수로 자르기

SUBSTRB 문자바이트로 자르기

**프로시저 디버그 할때(오류,반환)
RAISE_APPLICATION_ERROR (-20001, SQLERRM); 넣어서 찾아보기

**DBLINK 디비링크 코드

SELECT *
  FROM ALL_DB_LINKS
  
CREATE DATABASE LINK 링크명
CONNECT TO 계정ID
IDENTIFIED BY 계정PW

DROP DATABASE LINK 링크명

**타임스탬프(마이크로세컨드 까지 계산)
SELECT TO_CHAR(SYSTIMESTAMP, 'YYYYMMDDHH24MISSFF3') FROM DUAL

**테이블명 변경(RENAME)
ALTER TABLE 구테이블명  RENAME TO 신테이블명 

**컬럼명 변경

ALTER TABLE  LGD_COST_CHECK  RENAME COLUMN AA TO BB

ALTER TABLE  LGD_COST_CHECK  RENAME COLUMN MODE1 TO "MODE"

(에러날때) 예약어를 넣고싶을때는 " " 으로 스트링처리를 해주면된다.

**디비링크걸어서 테이블 만들기 OR 입력

CREATE TABLE FMS_FRT_RATE AS SELECT * FROM FmsFrtRate@DL_LGD WHERE 1=2

INSERT INTO LGD_ITTS_TSR *
SELECT * FROM LGDITTSTSR@DL_LGD;

**드랍 테이블 복구

flashback table FMS_HBL_OTH to before drop;

**JOIN

예시

TMS_SO_MST A , TMS_SO_ALOC_MST B WHERE A.SO_NO = B.SO_NO - INNER JOIN

TMS_SO_MST A , TMS_SO_ALOC_MST B WHERE A.SO_NO = B.SO_NO(+) - LEFT OUTER JOIN

** IN 1000개 넘어갈때
select * from xxx where id in (1,2,3,..) -> select * from xxx where (0,id) in ((0,1), (0,2), (0,3)..)

SQL = AND INV_NO IN ('@INV_NO') -> AND (0,A.INV_NO) IN ((0,'@INV_NO'))
VB = INVNO.ToString.Replace(" ", "").Replace(";", "','") -> INVNO.Replace(" ", "").Replace(";", "'),(0,'")

**디버깅걸어서 확인해보기
RAISE_APPLICATION_ERROR(-20050,'Error Msg=[' || R_RTNMSG ||']'); 
            RETURN;

						R_RTNCD := 'E';
            R_RTNMSG :='AAAA';
            RETURN;
            
**테이블 컬럼 비교

SELECT COLUMN_NAME,WM_CONCAT(TABLE_NAME),COUNT(TABLE_NAME) FROM
(SELECT COLUMN_NAME,'ACT_INV_DTL' AS TABLE_NAME
  FROM ALL_TAB_COLUMNS
  WHERE TABLE_NAME='ACT_INV_DTL' AND OWNER = 'ELVIS_MCI'
UNION ALL
SELECT COLUMN_NAME,'ACT_INV_MST' AS TABLE_NAME
  FROM ALL_TAB_COLUMNS
  WHERE TABLE_NAME='ACT_INV_MST' AND OWNER = 'ELVIS_MCI'
UNION ALL
  SELECT COLUMN_NAME,'ActSellBuyMst' AS TABLE_NAME
  FROM ALL_TAB_COLUMNS@DL_LGD
  WHERE TABLE_NAME='ActSellBuyMst' --대소문자 구분해야됨
UNION ALL
  SELECT COLUMN_NAME,'FmsFrtMst' AS TABLE_NAME
  FROM ALL_TAB_COLUMNS@DL_LGD
  WHERE TABLE_NAME='FmsFrtMst'
  )
  GROUP BY COLUMN_NAME
  HAVING COUNT(TABLE_NAME) != 4 
  
또는

SELECT COLUMN_NAME,WM_CONCAT(TABLE_NAME),COUNT(TABLE_NAME) FROM
(
  SELECT COLUMN_NAME,'A_FmsFrtMst' AS TABLE_NAME
  FROM ALL_TAB_COLUMNS@DL_LGD
  WHERE TABLE_NAME='FmsFrtMst' --대소문자 구분해야됨
UNION ALL
  SELECT COLUMN_NAME,'B_ACT_INV_DTL' AS TABLE_NAME
  FROM ALL_TAB_COLUMNS
  WHERE TABLE_NAME='ACT_INV_DTL' AND OWNER = 'ELVIS_MCI'
UNION ALL
SELECT COLUMN_NAME,'C_ACT_INV_MST' AS TABLE_NAME
  FROM ALL_TAB_COLUMNS
  WHERE TABLE_NAME='ACT_INV_MST' AND OWNER = 'ELVIS_MCI'
  )
  GROUP BY COLUMN_NAME
  ORDER BY WM_CONCAT(TABLE_NAME) ASC 
  
또는

SELECT COLUMN_NAME,WM_CONCAT(TABLE_NAME),COUNT(TABLE_NAME),WM_CONCAT(COPY) FROM
(
  SELECT COLUMN_NAME,'A_FmsInvMst' AS TABLE_NAME, 'X' AS COPY
  FROM ALL_TAB_COLUMNS@DL_LGD
  WHERE TABLE_NAME='FmsInvMst' --대소문자 구분해야됨
UNION ALL
  SELECT COLUMN_NAME,'B_ACT_INV_DTL' AS TABLE_NAME , 'ACT_INV_DTL' AS COPY
  FROM ALL_TAB_COLUMNS
  WHERE TABLE_NAME='ACT_INV_DTL' AND OWNER = 'ELVIS_MCI'
UNION ALL
SELECT COLUMN_NAME,'C_ACT_INV_MST' AS TABLE_NAME , 'ACT_INV_MST' AS COPY
  FROM ALL_TAB_COLUMNS
  WHERE TABLE_NAME='ACT_INV_MST' AND OWNER = 'ELVIS_MCI'
  )
  GROUP BY COLUMN_NAME
  ORDER BY WM_CONCAT(TABLE_NAME) ASC 
  
또는

SELECT COLUMN_NAME,WM_CONCAT(TABLE_NAME),COUNT(TABLE_NAME),NVL(WM_CONCAT(COPY),'X') FROM
(
  SELECT COLUMN_NAME,'A_FmsInvMst' AS TABLE_NAME, '' AS COPY
  FROM ALL_TAB_COLUMNS@DL_LGD
  WHERE TABLE_NAME='FmsInvMst' --대소문자 구분해야됨
UNION ALL
  SELECT COLUMN_NAME,'B_ACT_INV_MST' AS TABLE_NAME , 'ACT_INV_MST' AS COPY
  FROM ALL_TAB_COLUMNS
  WHERE TABLE_NAME='ACT_INV_MST' AND OWNER = 'ELVIS_MCI'
UNION ALL
  SELECT COLUMN_NAME,'B_ACT_INV_DTL' AS TABLE_NAME , 'ACT_INV_DTL' AS COPY
  FROM ALL_TAB_COLUMNS
  WHERE TABLE_NAME='ACT_INV_DTL' AND OWNER = 'ELVIS_MCI'
  )
  GROUP BY COLUMN_NAME
  ORDER BY WM_CONCAT(TABLE_NAME) ASC 
 
또는

 SELECT COLUMN_NAME,WM_CONCAT(TABLE_NAME),COUNT(TABLE_NAME),WM_CONCAT(COPY) FROM
(
  SELECT COLUMN_NAME,'A_FMS_HBL_MST' AS TABLE_NAME, 'FMS_HBL_MST' AS COPY
  FROM ALL_TAB_COLUMNS
  WHERE TABLE_NAME='FMS_HBL_MST' AND OWNER = 'ELVIS_MCI' --대소문자 구분해야됨
UNION ALL
  SELECT COLUMN_NAME,'B_FMS_HBL_OTH' AS TABLE_NAME , 'FMS_HBL_OTH' AS COPY
  FROM ALL_TAB_COLUMNS
  WHERE TABLE_NAME='FMS_HBL_OTH' AND OWNER = 'ELVIS_MCI'
  UNION ALL
  SELECT COLUMN_NAME,'C_FMS_HBL_ED' AS TABLE_NAME , 'FMS_HBL_ED' AS COPY
  FROM ALL_TAB_COLUMNS
  WHERE TABLE_NAME='FMS_HBL_ED' AND OWNER = 'ELVIS_MCI'
  UNION ALL
  SELECT COLUMN_NAME,'D_FMS_HBL_DOC' AS TABLE_NAME , 'FMS_HBL_DOC' AS COPY
  FROM ALL_TAB_COLUMNS
  WHERE TABLE_NAME='FMS_HBL_DOC' AND OWNER = 'ELVIS_MCI'
  )
  GROUP BY COLUMN_NAME
  ORDER BY WM_CONCAT(TABLE_NAME) ASC 
  
**UNION ALL 에러날경우 (UNION ALL 시스템상 에러를 뱉게 되어있음 - ORDER BY 안되게 막혀있음)

SELECT * FROM AA
ORDER BY ~
UNION ALL
SELECT * FROM AA

SELECT * FROM (SELECT * FROM AA ORDER NY ~) 
UNION ALL
SELECT * FROM AA

**계정과목 중복 체크
SELECT A.OFFICE_CD,A.ACCT_CD,A.ACCT_NM,B.OFFICE_CD,B.ACCT_CD,B.ACCT_NM FROM
(SELECT OFFICE_CD,ACCT_CD,ACCT_NM FROM ACT_CODE_MST WHERE OFFICE_CD ='MCISEL' GROUP BY OFFICE_CD,ACCT_CD,ACCT_NM) A
, (SELECT OFFICE_CD,WM_CONCAT(ACCT_CD) ACCT_CD,ACCT_NM FROM ACT_CODE_MST@DL_MEXG WHERE OFFICE_CD='MEXG' GROUP BY OFFICE_CD,ACCT_NM)B
WHERE A.ACCT_NM = B.ACCT_NM(+)

**OUTJOIN 하나씩만 가지고오기

SELECT * FROM (SELECT ACCT_NM,ROW_NUMBER() OVER(PARTITION BY ACCT_NM ORDER BY ACCT_NM) AS SEQ FROM ACT_CODE_MST@DL_MEXG WHERE OFFICE_CD='MEXG') WHERE SEQ>1
로 묶던가해서 JOIN 해야될듯

**DB링크로 INSERT할때 ORA-12899 열에대한값이너무큼 오류나오면

BACK 테이블로 CRATE TABLE SELECT 로 데이터 받은다음에 데이터만 다시 옮겨주자

** TRUNCATE TABLE LGD_INV_SEQ 테이블 데이터만 전부날림

**문자집합이 일치하지 않습니다. ORA - 21704
TO_CHAR() 로 감싸주기
VARCHAR <> VARCHAR2

**FMS_EDI_MST_TEMP -> FMS_EDI_MST 데이터 옮기기
INSERT INTO FMS_EDI_MST
SELECT 
            SUBSTR(TO_CHAR(TRMS_REQ_YMD,'YYYYMMDD HH24MISS'),1,8) AS TRMS_REQ_YMD
           ,SUBSTR(TO_CHAR(TRMS_REQ_YMD,'YYYYMMDD HH24MISS'),10,6) AS TRMS_REQ_HM
           ,NVL(TRMS_DOC_NO, TO_CHAR(TRMS_REQ_YMD,'YYYYMMDD HH24MISS') || NVL(MNGT_NO,'-')) AS TRMS_DOC_NO
           ,SUBSTR(NVL(MNGT_NO, TO_CHAR(TRMS_REQ_YMD,'YYYYMMDD HH24MISS') || NVL(TRMS_DOC_NO,'-')),1,20) AS MNGT_NO
           ,DOC_TYPE
           ,'' SR_NO
           ,FILE_NM
           ,DOC_PATH
           ,TRMS_REQ_USR AS TRMS_PIC
           ,SUBSTR(TRMS_STAT,1,1) AS MSG_FUNC
           ,'' CONTENT
           ,TRMS_TYPE
           ,'' DEL_RSN_CD
           ,'' DEL_RSN_NM
           ,'' BLL_RSN_CD
           ,'' BLL_TYPE
FROM FMS_EDI_MST_TEMP

** INSERT INTO LGD_EDIMANAGE (
       MSGID,
       TRANSTYPECODE,
       SYSTEMID,
       SENDERID,
       RECEIVERID,
       DOCAGENCYID,
       DOCID,
       MSGFUNCCODE,
       DOCNO,
       SENDCNT,
       REFCLSCODE,
       REFID,
       REFNO,
       REMARK,
       FILENAME,
       ISCONFIRMED,
       CREATEDATETIME,
       SENDDATETIME,
       ISVALID,
       ACKID,
       GENRESID,
       INSUSERCODE,
       INSDATETIME,
       UPDUSERCODE,
       UPDDATETIME,
       TABNAM,
       MANDT,
       DOCREL,
       STATUS,
       DIRECT,
       OUTMOD,
       IDOCTYP,
       SNDPOR,
       SNDPRT,
       SNDPFC,
       SNDPRN,
       RCVPOR,
       RCVPRT,
       RCVPFC,
       RCVPRN,
       CREDAT,
       CRETIM,
       SERIAL
)
VALUES (
      '@MSGID',
      '@TRANSTYPECODE',
      '@SYSTEMID',
      '@SENDERID',
      '@RECEIVERID',
      '@DOCAGENCYID',
      '@DOCID',
      '@MSGFUNCCODE',
      '@DOCNO',
      '@SENDCNT',
      '@REFCLSCODE',
      '@REFID',
      '@REFNO',
      '@REMARK',
      '@FILENAME',
      '@ISCONFIRMED',
      '@CREATEDATETIME',
      '@SENDDATETIME',
      '@ISVALID',
      '@ACKID',
      '@GENRESID',
      '@INSUSERCODE',
      '@INSDATETIME',
      '@UPDUSERCODE',
      '@UPDDATETIME',
      '@TABNAM',
      '@MANDT',
      '@DOCREL',
      '@STATUS',
      '@DIRECT',
      '@OUTMOD',
      '@IDOCTYP',
      '@SNDPOR',
      '@SNDPRT',
      '@SNDPFC',
      '@SNDPRN',
      '@RCVPOR',
      '@RCVPRT',
      '@RCVPFC',
      '@RCVPRN',
      '@CREDAT',
      '@CRETIM',
      '@SERIAL'
    )
    
*ORA-01045
grant create session to 유저명;

*IP확인
select SYS_CONTEXT('USERENV', 'IP_ADDRESS', 15) ipaddr from dual

*프로시저 내용 검색
SELECT * FROM USER_SOURCE WHERE TYPE = 'PROCEDURE' AND TEXT LIKE '%USP_WO_PROFIT%'

*함수 내용 검색
SELECT * FROM USER_SOURCE WHERE TYPE = 'FUNCTION' AND TEXT LIKE '%USP_WO_PROFIT%'

*커서루프(CURSOR)
OPEN C1;
               
               LOOP
                 
                FETCH C1 INTO C1_REC; --담을 변수를 INTO 안에 넣어야함
                EXIT WHEN C1%NOTFOUND;    
                
                BEGIN
                    v_query := ALTER TABLE C1_REC.TABLENAME RENAME TO 'DD_'||C1_REC.TABLENAME
                END;               
                              
               END LOOP; 
               
CLOSE C1;

*커서선언,레코드 선언
CURSOR C1 IS
    SELECT ~~ FROM ~~;
    
C1_REC C1%ROWTYPE;

*계층적 쿼리 메뉴코드 가지고오기 참조:https://blog.kjslab.com/11
                 SELECT *
                   FROM ADT_CSY_MENU T1
                 WHERE APPCODE = 'C-PORTAL' AND MENUCODE LIKE 'PTL66%'
         START WITH SUPERMENUCODE = '-1'
CONNECT BY PRIOR MENUCODE = SUPERMENUCODE
ORDER SIBLINGS BY ORDERS ASC;

*계층적 쿼리 메뉴 Insert 시키기
INSERT INTO ADT_CSY_SEARCHCONDITION
SELECT A.MENUCODE, B.LINENUMBER, B.DBCOLUMN, B.COLUMNDESCR, B.TYPE, B.DATATYPE, B.REQUIREMENT, B.OPERATOR, B.OPERATORFIX, B.DEFAULTVALUE, B.VALIDDAYS, B.SQLPROP, B.KEYPARAM, B.PARAM1, B.PARAM2, B.PARAM3, B.PARAM4, B.PARAM5, B.PARAM6, B.PARAM7, B.PARAM8, B.PARAM9, B.PARAM10, B.USEYN, B.ADDDATE, B.ADDWHO, B.EDITDATE, B.EDITWHO, B.MODULE, B.PAGESIZE, B.NEXTLINE, B.CUSTOMPOPFUNCTION, B.SELECTIONMODE, B.UPPERCASE
 FROM
(SELECT decode(rownum, 1,'PTL822109', 2, 'PTL821109', 3,'PTL823800' ) AS MENUCODE, 'LINK' AS LINK from dual connect by level <= 3) A, 
(SELECT 'LINK' AS LINK,A.* FROM ADT_CSY_SEARCHCONDITION A WHERE MENUCODE = 'FIS500100') B
WHERE A.LINK = B.LINK(+)


